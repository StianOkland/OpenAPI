import React__default, { createRef, createElement, Component } from 'react';
import singleline from 'singleline';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var INITIALISE = 'INITIALISE';
var SET_IS_DRAGGING = 'SET_IS_DRAGGING';
var SET_OPTIONS_PANEL_OPEN = 'SET_OPTIONS_PANEL_OPEN';
var SET_OPTIONS_PANEL_CLOSED = 'SET_OPTIONS_PANEL_CLOSED';
var SET_SINGLESELECT_OPTIONS = 'SET_SINGLESELECT_OPTIONS';
var SET_MULTISELECT_OPTIONS = 'SET_MULTISELECT_OPTIONS';
var SET_OPTIONS_PANEL_CLOSED_NO_SELECTION = 'SET_OPTIONS_PANEL_CLOSED_NO_SELECTION';
var SET_OPTIONS_PANEL_CLOSED_ONBLUR = 'SET_OPTIONS_PANEL_CLOSED_ONBLUR';
var SET_NEXT_SELECTED_INDEX = 'SET_NEXT_SELECTED_INDEX';
var SET_NEXT_SELECTED_INDEX_ALPHA_NUMERIC = 'SET_NEXT_SELECTED_INDEX_ALPHA_NUMERIC';

var stringMatch = '';
var timeoutActive;
/**
 * User types some keys in quick successsion whilst focused on a select - search for this combonation in their options
 */

function handleAlphaNumerical(_ref) {
  var event = _ref.event,
      state = _ref.state,
      RRSClassRef = _ref.RRSClassRef;
  var options = state.options,
      disabled = state.disabled;
  if (disabled) return; // Accumulate users key presses

  stringMatch = stringMatch + event.key;

  if (!timeoutActive) {
    timeoutActive = true; // Eventually (after 250ms) check if the accumulation of their keypresses matches the text of an option

    setTimeout(function () {
      var foundIndexes = options.reduce(function (acc, option, index) {
        if (!option.optHeader && !option.disabled && option.text && option.text.toLowerCase().indexOf(stringMatch) !== -1) {
          acc.push(index);
        }

        return acc;
      }, []);

      if (foundIndexes.length > 0) {
        RRSClassRef.updateState({
          value: foundIndexes[0],
          type: SET_NEXT_SELECTED_INDEX_ALPHA_NUMERIC
        });
      } // allow for the creation of a new search


      timeoutActive = false;
      stringMatch = '';
    }, 250);
  }
}

var skipCircularReference = function skipCircularReference() {
  var cache = [];
  return function (_key, value) {
    if (typeof value === 'object' && value !== null) {
      // Circular reference found
      if (cache.indexOf(value) !== -1) return;
      cache.push(value);
    } // No circular reference found


    return value;
  };
};

function isEqual(a, b) {
  return JSON.stringify(a, skipCircularReference()) === JSON.stringify(b, skipCircularReference());
}

function multiSelectBroadcastChange(currOptions, altered, fn, prevOptions) {
  if (!fn) return;
  var shouldBroadcastChange = !prevOptions || !isEqual(prevOptions.values, currOptions.values);

  if (shouldBroadcastChange) {
    fn({
      options: currOptions.map(function (currOption) {
        return {
          name: currOption.name || '',
          text: currOption.text || '',
          value: currOption.value || ''
        };
      }),
      altered: altered
    });
  }
}

function singleSelectBroadcastChange(currValue, altered, fn, prevValue) {
  if (!fn) return;
  var shouldBroadcastChange = !isEqual(prevValue == null ? void 0 : prevValue.value, currValue == null ? void 0 : currValue.value);

  if (shouldBroadcastChange) {
    fn({
      name: currValue.name,
      text: currValue.text,
      value: currValue.value,
      altered: altered
    });
  }
}

function handleBlur(_ref) {
  var state = _ref.state,
      RRSClassRef = _ref.RRSClassRef,
      props = _ref.props;
  var onBlur = props.onBlur,
      multiselect = props.multiselect;
  var isOptionsPanelOpen = state.isOptionsPanelOpen,
      disabled = state.disabled,
      altered = state.altered,
      singleSelectSelectedOption = state.singleSelectSelectedOption,
      multiSelectSelectedOptions = state.multiSelectSelectedOptions;
  if (disabled) return;
  var isOutsideSelectBox = RRSClassRef.selectBox && !RRSClassRef.selectBox.contains(document.activeElement);
  /* Handle click outside of selectbox */

  if (isOptionsPanelOpen && isOutsideSelectBox) {
    RRSClassRef.updateState({
      type: SET_OPTIONS_PANEL_CLOSED_ONBLUR
    });
  }

  if (isOutsideSelectBox && onBlur) {
    if (multiselect) {
      multiSelectBroadcastChange(multiSelectSelectedOptions.options, Boolean(altered), onBlur);
    } else {
      singleSelectBroadcastChange(singleSelectSelectedOption, Boolean(altered), onBlur);
    }
  }
}

function containsClassName(element, classNameStr) {
  return String(element.className).split(' ').indexOf(classNameStr) > -1;
}

function handleClick(_ref) {
  var event = _ref.event,
      state = _ref.state,
      RRSClassRef = _ref.RRSClassRef,
      props = _ref.props;
  var multiselect = state.multiselect,
      multiSelectSelectedOptions = state.multiSelectSelectedOptions,
      isOptionsPanelOpen = state.isOptionsPanelOpen,
      isDragging = state.isDragging,
      disabled = state.disabled,
      options = state.options;
  if (disabled) return;

  if (isDragging === false) {
    /* Disallow natural event flow - don't allow blur to happen from button focus to selected option focus */
    event.preventDefault();

    if (event && containsClassName(event.target, 'rrs__options')) {
      return;
    }

    var value = parseFloat(event.target.getAttribute('data-key'));

    if (options[value] && (options[value].disabled === true || options[value].optHeader === true)) {
      return;
    }
    /* Select option index, if user selected option */


    if (containsClassName(event.target, 'rrs__option')) {
      if (multiselect) {
        var isExistingSelection = multiSelectSelectedOptions.options.some(function (option) {
          return options[value] && options[value].hasOwnProperty('value') && option.value === options[value].value;
        });

        if (!isExistingSelection && props.onSelect) {
          props.onSelect(options[value]);
        } else if (isExistingSelection && props.onDeselect) {
          props.onDeselect(options[value]);
        }
      } else if (!multiselect && props.onSelect) {
        props.onSelect(options[value]);
      }

      RRSClassRef.updateState({
        type: multiselect ? SET_MULTISELECT_OPTIONS : SET_SINGLESELECT_OPTIONS,
        value: value
      });
      return;
    }
    /*
      When the options panel is open, treat clicking the label/select button
      or the background overlay on small screen as a 'no action'
    */


    if (isOptionsPanelOpen && ( // button on desktop (rrs__label) or overlay on small screen (rrs)
    containsClassName(event.target, 'rrs__label') || containsClassName(event.target, 'rrs'))) {
      RRSClassRef.updateState({
        type: SET_OPTIONS_PANEL_CLOSED_NO_SELECTION
      }, function () {
        return RRSClassRef.focusButton();
      });
      return;
    }
    /* Else user clicked close or open the options panel */


    RRSClassRef.updateState({
      type: isOptionsPanelOpen ? SET_OPTIONS_PANEL_CLOSED : SET_OPTIONS_PANEL_OPEN
    }, function (newState) {
      // After state update, check if focus should be moved to the button
      if (newState.isOptionsPanelOpen === false) {
        RRSClassRef.focusButton();
      }
    });
  }
}

function handleEnterPressed(_ref) {
  var event = _ref.event,
      state = _ref.state,
      props = _ref.props,
      RRSClassRef = _ref.RRSClassRef;
  var disabled = state.disabled,
      isOptionsPanelOpen = state.isOptionsPanelOpen,
      multiselect = state.multiselect,
      nextPotentialSelectionIndex = state.nextPotentialSelectionIndex,
      options = state.options;
  if (disabled) return;
  var value = parseFloat(event.target.getAttribute('data-key'));

  if (options[value] && (options[value].disabled === true || options[value].optHeader === true)) {
    return;
  }

  if (multiselect) {
    var isExistingSelection = state.multiSelectSelectedOptions.options.some(function (option) {
      return options[value] && options[value].hasOwnProperty('value') && option.value === options[value].value;
    });

    if (!isExistingSelection && props.onSelect) {
      props.onSelect(options[value]);
    } else if (isExistingSelection && props.onDeselect) {
      props.onDeselect(options[value]);
    }

    RRSClassRef.updateState({
      type: SET_MULTISELECT_OPTIONS,
      value: nextPotentialSelectionIndex
    });
  } else {
    if (props.onSelect) {
      props.onSelect(options[value]);
    }

    RRSClassRef.updateState({
      type: SET_SINGLESELECT_OPTIONS,
      value: nextPotentialSelectionIndex
    });
  }

  if (isOptionsPanelOpen) {
    event.stopPropagation(); // Do not submit form
  } else {
    // tslint:disable-next-line
    props.onSubmit && props.onSubmit(event); // Submit the form
  }
}

var keyCodes = {
  TAB: 9,
  ENTER: 13,
  SPACE: 32,
  ESCAPE: 27,
  UP: 38,
  DOWN: 40
};

function preventDefaultForKeyCodes(keyCodes, e) {
  keyCodes.forEach(function (keyCode) {
    if (keyCode === e.keyCode) {
      e.preventDefault();
    }
  });
}

function nextValidIndex(state, nextPotentialSelectionIndex, mode) {
  if (mode === void 0) {
    mode = 'INCREMENT';
  }

  var options = state.options;
  var possibleOptionIndexes = options.reduce(function (acc, option, index) {
    if (!option.optHeader) acc.push(index);
    return acc;
  }, []);
  var indexNotFocusable = possibleOptionIndexes.indexOf(nextPotentialSelectionIndex) === -1;

  if (indexNotFocusable && mode === 'INCREMENT') {
    var nextSelectionPossible = options[nextPotentialSelectionIndex + 1] && !options[nextPotentialSelectionIndex + 1].optHeader;
    return nextSelectionPossible ? nextPotentialSelectionIndex + 1 : possibleOptionIndexes[0];
  }

  if (indexNotFocusable && mode === 'DECREMENT') {
    var _nextSelectionPossible = options[nextPotentialSelectionIndex - 1] && !options[nextPotentialSelectionIndex - 1].optHeader;

    return _nextSelectionPossible ? nextPotentialSelectionIndex - 1 : possibleOptionIndexes[possibleOptionIndexes.length - 1];
  }

  return nextPotentialSelectionIndex;
}

function getNextIndex(mode, state) {
  var isOptionsPanelOpen = state.isOptionsPanelOpen,
      nextPotentialSelectionIndex = state.nextPotentialSelectionIndex,
      options = state.options;

  switch (mode) {
    case 'INCREMENT':
      // Hold selection on current selected option when options panel first opens
      if (isOptionsPanelOpen === false) {
        return nextValidIndex(state, nextPotentialSelectionIndex, 'INCREMENT');
      } // User is at the end of the options so cycle back to start


      if (nextPotentialSelectionIndex === options.length - 1) {
        return nextValidIndex(state, 0, 'INCREMENT');
      } // Else increment


      return nextValidIndex(state, nextPotentialSelectionIndex + 1, 'INCREMENT');

    case 'DECREMENT':
      // Hold selection on current selected option when options panel first opens
      if (isOptionsPanelOpen === false) {
        return nextValidIndex(state, nextPotentialSelectionIndex, 'DECREMENT');
      } // User is at start of the options so cycle around to end


      if (nextPotentialSelectionIndex === 0) {
        return nextValidIndex(state, options.length - 1, 'DECREMENT');
      } // Else decrement


      return nextValidIndex(state, nextPotentialSelectionIndex - 1, 'DECREMENT');

    default:
      return nextValidIndex(state, 0, 'DECREMENT');
  }
}

function handleKeyUpOrDownPressed(_ref) {
  var state = _ref.state,
      RRSClassRef = _ref.RRSClassRef,
      type = _ref.type;
  var isOptionsPanelOpen = state.isOptionsPanelOpen,
      disabled = state.disabled;
  if (disabled) return;
  RRSClassRef.updateState({
    type: SET_NEXT_SELECTED_INDEX,
    value: getNextIndex(type, state)
  });
  /* Open the options panel */

  if (isOptionsPanelOpen === false) {
    RRSClassRef.updateState({
      type: SET_OPTIONS_PANEL_OPEN
    });
  }
}

function handleKeyEvent(_ref) {
  var event = _ref.event,
      state = _ref.state,
      props = _ref.props,
      RRSClassRef = _ref.RRSClassRef;
  var multiselect = state.multiselect,
      isOptionsPanelOpen = state.isOptionsPanelOpen,
      disabled = state.disabled;
  if (disabled) return;
  preventDefaultForKeyCodes([keyCodes.ENTER, keyCodes.SPACE, keyCodes.ESCAPE, keyCodes.UP, keyCodes.DOWN], event);
  /* handle alpha-nemeric key press */

  if (/^[a-z0-9]+$/.test(event.key)) {
    handleAlphaNumerical({
      event: event,
      RRSClassRef: RRSClassRef,
      state: state
    });
  }

  switch (event.keyCode) {
    case keyCodes.TAB:
      /* Don't shift focus when the panel is open (unless it's a Multiselect) */
      if (isOptionsPanelOpen) {
        event.preventDefault();
        /**
         * Multiselect does not close on selection. Focus button to blur and close options panel on TAB
         * TODO add a test for this
         */

        if (multiselect) {
          RRSClassRef.updateState({
            type: SET_OPTIONS_PANEL_CLOSED
          }, function () {
            return RRSClassRef.focusButton();
          });
        }
      }

      break;

    case keyCodes.ENTER:
      /* can close the panel when open and focussed
       * can submit the form when closed and focussed */
      handleEnterPressed({
        RRSClassRef: RRSClassRef,
        event: event,
        props: props,
        state: state
      });
      break;

    case keyCodes.SPACE:
      /* close the panel and select option when open, or open the panel if closed */
      if (isOptionsPanelOpen) {
        handleClick({
          event: event,
          state: state,
          RRSClassRef: RRSClassRef,
          props: props
        });
      } else {
        RRSClassRef.updateState({
          type: SET_OPTIONS_PANEL_OPEN
        });
      }

      break;

    case keyCodes.ESCAPE:
      /* remove focus from the panel when focussed */
      RRSClassRef.updateState({
        type: SET_OPTIONS_PANEL_CLOSED_NO_SELECTION
      }, function () {
        return RRSClassRef.focusButton();
      });
      break;

    case keyCodes.UP:
      /* will open the options panel if closed
       * will not decrement selection if options panel closed
       * if panel open, will decrement up the options list */
      handleKeyUpOrDownPressed({
        RRSClassRef: RRSClassRef,
        state: state,
        type: 'DECREMENT'
      });
      break;

    case keyCodes.DOWN:
      /* will open the options panel if closed
       * will not increment selection if options panel closed
       * if panel open, will increment down the options list */
      handleKeyUpOrDownPressed({
        RRSClassRef: RRSClassRef,
        state: state,
        type: 'INCREMENT'
      });
      break;
  }
}

function handleTouchMove(_ref) {
  var state = _ref.state,
      RRSClassRef = _ref.RRSClassRef;

  /* if touchmove fired - User is dragging, this disables touchend/click */
  var isDragging = state.isDragging,
      disabled = state.disabled;
  if (disabled) return;

  if (!isDragging) {
    RRSClassRef.updateState({
      type: SET_IS_DRAGGING,
      value: true
    });
  }
}

function handleTouchStart(_ref) {
  var state = _ref.state,
      RRSClassRef = _ref.RRSClassRef;
  var disabled = state.disabled;
  if (disabled) return;
  /* initially it's assumed that the user is not dragging */

  RRSClassRef.updateState({
    type: SET_IS_DRAGGING,
    value: false
  });
}

function getCustomLabelText(_ref) {
  var state = _ref.state,
      props = _ref.props;
  var multiselect = props.multiselect,
      customLabelRenderer = props.customLabelRenderer;
  var multiSelectSelectedOptions = state.multiSelectSelectedOptions,
      singleSelectSelectedOption = state.singleSelectSelectedOption;
  if (!customLabelRenderer) return false;

  if (multiselect) {
    return customLabelRenderer(multiSelectSelectedOptions);
  }

  return customLabelRenderer(singleSelectSelectedOption);
}

var initialState = {
  // Constants
  multiselect: false,
  // Universal
  name: '',
  options: [],
  isDragging: false,
  isOptionsPanelOpen: false,
  altered: false,
  // Single select
  singleSelectInitialIndex: 0,
  singleSelectSelectedIndex: 0,
  singleSelectSelectedOption: {},
  // For determining highlighted item on Keyboard navigation
  nextPotentialSelectionIndex: 0,
  // Multi select
  multiSelectInitialSelectedIndexes: [0],
  multiSelectSelectedOptions: {
    altered: false,
    options: []
  },
  multiSelectSelectedIndexes: []
};

function addMultiSelectIndex(state, index) {
  return [].concat(state.multiSelectSelectedIndexes, [index]);
}

function addMultiSelectOption(state, index) {
  return {
    options: [].concat(state.multiSelectSelectedOptions.options, [{
      name: state.name,
      text: state.options[index].text,
      value: state.options[index].value
    }])
  };
}

function findClosestValidOption(state) {
  var options = state.options,
      name = state.name;
  var possibleOptions = options.reduce(function (acc, option, index) {
    if (!option.optHeader) {
      acc.push({
        option: {
          value: option.value,
          text: option.text,
          name: name
        },
        index: index
      });
    }

    return acc;
  }, []); // Note: Will fail if there is only one option, and it is an optHeader

  return possibleOptions[0];
}

function getInitialMultiSelectOption(state) {
  //: { option: IOutputMultiSelectOptionSansDisabled; index: number; }
  var _findClosestValidOpti = findClosestValidOption(state),
      option = _findClosestValidOpti.option,
      index = _findClosestValidOpti.index;

  return _extends({}, state, {
    multiSelectSelectedIndexes: [index],
    multiSelectSelectedOptions: {
      options: [_extends({}, option)]
    },
    nextPotentialSelectionIndex: index
  });
}

/* Use existing state.singleSelectSelectedOption, or first possible option to use as a selection */
function findClosestValidOption$1(state) {
  var multiSelectSelectedOptions = state.multiSelectSelectedOptions,
      options = state.options,
      name = state.name;

  if (multiSelectSelectedOptions && multiSelectSelectedOptions.options.length) {
    return multiSelectSelectedOptions.options[0];
  }

  var possibleOptions = options.reduce(function (acc, option) {
    if (!option.optHeader) acc.push(option);
    return acc;
  }, []); // Note: Will fail if no non-optHeader options exist

  return {
    name: name,
    text: possibleOptions[0].text,
    value: possibleOptions[0].value
  };
}

function getMultiSelectInitialSelectedOptions(state, selectedValues) {
  var noSelectionLabel = state.noSelectionLabel,
      options = state.options,
      name = state.name;
  var selectedOptionsToReturn;

  if (!noSelectionLabel) {
    // Preselect the first item in the list when if no noSelectionLabel exists
    if (selectedValues && selectedValues.length > 0) {
      // Grab selected options by matching option.value with selectedValues, and merge in `name`
      selectedOptionsToReturn = options.filter(function (option) {
        return selectedValues.some(function (selectedValue) {
          return selectedValue === option.value;
        });
      }).map(function (option) {
        return _extends({
          name: name
        }, option);
      });
    } else {
      // Grab first option and merge in `name`
      var option = options[0] && options[0].optHeader ? findClosestValidOption$1(state) : options[0];
      selectedOptionsToReturn = [{
        name: name,
        text: option.text,
        value: option.value
      }];
    }

    return selectedOptionsToReturn;
  }

  selectedOptionsToReturn = selectedValues && selectedValues.length > 0 ? options.reduce(function (acc, option) {
    if (selectedValues.some(function (selectedValue) {
      return selectedValue === option.value;
    })) {
      acc.push(_extends({}, option));
    }

    return acc;
  }, []) : [{
    name: state.name,
    text: noSelectionLabel,
    value: 'null'
  }];
  return selectedOptionsToReturn;
}

function getMultiSelectSelectedValueIndexes(state, selectedValues, noSelectionLabel) {
  if (selectedValues === void 0) {
    selectedValues = [];
  }

  var options = state.options;
  var emptyResult = noSelectionLabel ? [] : [nextValidIndex(state, 0)];
  /* return the index of the found item, if found */

  var result = options.reduce(function (acc, option, value) {
    if (selectedValues.some(function (selected) {
      return option.value === selected;
    })) {
      acc.push(value);
    }

    return acc;
  }, []);
  /* If something found return that, else return the first item */

  return result.length > 0 ? result : emptyResult;
}

function getSelectedValueIndex(_ref) {
  var options = _ref.options,
      selectedValue = _ref.selectedValue,
      noSelectionLabel = _ref.noSelectionLabel;
  var index = selectedValue ? options.map(function (option) {
    return option.value;
  }).indexOf(selectedValue) : -1; // Allow a negative index if user wants to display a noSelectionLabel
  // Keyboard will not focus on an option when first opened
  // Select the first option when panel opens if !noSelectionLabel

  return index > -1 || noSelectionLabel ? index : 0;
}

/*
  use existing state.singleSelectSelectedOption, or first possible option to use as a selection
*/
function closestValidOption(state) {
  if (state.singleSelectSelectedOption) {
    return state.singleSelectSelectedOption;
  }

  var possibleOptions = state.options.reduce(function (acc, option) {
    if (!option.optHeader) {
      acc.push(option);
    }

    return acc;
  }, []); // Note: Will fail if no non-optHeader options exist

  return _extends({}, possibleOptions[0], {
    name: state.name
  });
}

function getSingleSelectSelectedOption(state, initialSelectedIndex) {
  if (initialSelectedIndex === void 0) {
    initialSelectedIndex = 0;
  }

  var selectionIndex = initialSelectedIndex === -1 && !state.noSelectionLabel ? 0 : initialSelectedIndex; // if optHeader, then use existing state.singleSelectSelectedOption, or findClosestValidOption

  if (state.options[selectionIndex] && state.options[selectionIndex].optHeader) {
    return closestValidOption(state);
  } // Has selection, has no selection use default noSelectionLabel (if exists) and nullify value


  if (!state.noSelectionLabel) {
    // Preselect the first item in the list when if no noSelectionLabel exists
    return _extends({
      name: state.name
    }, state.options[selectionIndex]);
  }

  return initialSelectedIndex > -1 ? _extends({
    name: state.name
  }, state.options[initialSelectedIndex]) : {
    name: state.name,
    text: state.noSelectionLabel,
    value: 'null'
  };
}

function isAltered(newState) {
  return !newState.multiselect ? newState.singleSelectSelectedIndex !== newState.singleSelectInitialIndex : !(JSON.stringify(newState.multiSelectInitialSelectedIndexes) === JSON.stringify(newState.multiSelectSelectedIndexes));
}
function mergeIsAlteredState(newState) {
  return _extends({}, newState, {
    altered: isAltered(newState)
  });
}

function removeMultiSelectIndex(state, indexLocation) {
  return [].concat(state.multiSelectSelectedIndexes.slice(0, indexLocation), state.multiSelectSelectedIndexes.slice(indexLocation + 1));
}

function removeMultiSelectOption(state, indexLocation) {
  return {
    options: [].concat(state.multiSelectSelectedOptions.options.slice(0, indexLocation), state.multiSelectSelectedOptions.options.slice(indexLocation + 1))
  };
}

function resetMultiSelectState(state) {
  return _extends({}, state, {
    multiSelectSelectedIndexes: [].concat(initialState.multiSelectSelectedIndexes),
    multiSelectSelectedOptions: _extends({}, initialState.multiSelectSelectedOptions)
  });
}

function reducer(state, action) {
  switch (action.type) {
    case INITIALISE:
      {
        var initialSelectedIndex = getSelectedValueIndex(action.value);
        var initialSelectedIndexes = getMultiSelectSelectedValueIndexes(action.value, action.value.selectedValues, action.value.noSelectionLabel);
        return _extends({}, state, {
          hasOptHeaders: action.value.options.some(function (option) {
            return option.optHeader === true;
          }),
          // Constants
          multiselect: action.value.multiselect || false,
          // Optional nothing selected label
          noSelectionLabel: action.value.noSelectionLabel,
          // Universal
          name: action.value.name,
          options: action.value.options,
          altered: action.value.altered || false,
          disabled: action.value.options.length === 0 || action.value.disabled || false,
          // Single select
          singleSelectInitialIndex: initialSelectedIndex,
          singleSelectSelectedIndex: initialSelectedIndex,
          singleSelectSelectedOption: getSingleSelectSelectedOption(action.value, initialSelectedIndex),
          nextPotentialSelectionIndex: state.nextPotentialSelectionIndex ? state.nextPotentialSelectionIndex : initialSelectedIndex,
          // Multi select
          multiSelectInitialSelectedIndexes: initialSelectedIndexes,
          multiSelectSelectedIndexes: initialSelectedIndexes,
          multiSelectSelectedOptions: {
            options: action.value.options.length > 0 ? getMultiSelectInitialSelectedOptions(action.value, action.value.selectedValues) : []
          }
        });
      }

    case SET_IS_DRAGGING:
      return _extends({}, state, {
        isDragging: action.value
      });

    case SET_OPTIONS_PANEL_OPEN:
      {
        var newState = _extends({}, state, {
          isOptionsPanelOpen: true,
          // For determining highlighted item on Keyboard navigation
          nextPotentialSelectionIndex: function () {
            if (state.multiselect) {
              return state.multiSelectSelectedIndexes.length ? nextValidIndex(state, state.multiSelectSelectedIndexes[0]) : nextValidIndex(state, 0);
            }

            return nextValidIndex(state, state.nextPotentialSelectionIndex);
          }(),
          singleSelectSelectedOption: getSingleSelectSelectedOption(state, state.nextPotentialSelectionIndex)
        });

        return mergeIsAlteredState(newState);
      }

    case SET_OPTIONS_PANEL_CLOSED:
      {
        var _newState = _extends({}, state, {
          isOptionsPanelOpen: false,
          singleSelectSelectedIndex: state.nextPotentialSelectionIndex,
          singleSelectSelectedOption: getSingleSelectSelectedOption(state, state.nextPotentialSelectionIndex)
        });

        return mergeIsAlteredState(_newState);
      }

    case SET_OPTIONS_PANEL_CLOSED_NO_SELECTION:
    case SET_OPTIONS_PANEL_CLOSED_ONBLUR:
      return _extends({}, state, {
        isOptionsPanelOpen: false
      });

    case SET_NEXT_SELECTED_INDEX:
      return _extends({}, state, {
        nextPotentialSelectionIndex: action.value
      });

    case SET_NEXT_SELECTED_INDEX_ALPHA_NUMERIC:
      return _extends({}, state, {
        isOptionsPanelOpen: true,
        nextPotentialSelectionIndex: action.value
      });

    case SET_SINGLESELECT_OPTIONS:
      {
        var nextState = _extends({}, state, {
          nextPotentialSelectionIndex: action.value,
          singleSelectSelectedIndex: action.value,
          isOptionsPanelOpen: false,
          singleSelectSelectedOption: getSingleSelectSelectedOption(state, action.value)
        }); // Set altered state


        return mergeIsAlteredState(nextState);
      }

    case SET_MULTISELECT_OPTIONS:
      {
        if (!state.noSelectionLabel) {
          var isFirstOptionInListSelected = state.multiSelectSelectedIndexes[0] === 0 && state.multiSelectSelectedIndexes.length === 1; // If anything selected and first option was requested, deselect all, then select first option

          var shouldDeselectAllAndSelectFirstOption = state.multiSelectSelectedIndexes.length > 0 && !isFirstOptionInListSelected && action.value === 0 && !state.noSelectionLabel; // Deselect first option when any other value is requested

          var shouldDeselectFirstOptionAndSelectRequestedOption = isFirstOptionInListSelected && action.value !== 0; // If any thing selected and first option was requested, deselect all, and return first option

          if (shouldDeselectAllAndSelectFirstOption) {
            return mergeIsAlteredState(getInitialMultiSelectOption(state));
          } // Deselect first option when first option selected and another option is requested


          if (shouldDeselectFirstOptionAndSelectRequestedOption) {
            // eslint-disable-next-line no-param-reassign
            state = resetMultiSelectState(state);
          }
        } // Remove noSelectionLabel from selected options if something is selected


        if (state.noSelectionLabel && state.multiSelectSelectedOptions.options[0].text === state.noSelectionLabel) {
          // eslint-disable-next-line no-param-reassign
          state.multiSelectSelectedOptions.options = [];
        } // With optHeader, action.value can go out of bounds - check and adjust the value of value when requried


        var actionOptionIndexAdjusted = nextValidIndex(state, action.value); // Find index of requested option

        var indexLocation = state.multiSelectSelectedIndexes.indexOf(actionOptionIndexAdjusted); // If requested item does not exist, add it. Else remove it

        var _nextState = _extends({}, state, {
          nextPotentialSelectionIndex: actionOptionIndexAdjusted,
          multiSelectSelectedIndexes: indexLocation === -1 ? addMultiSelectIndex(state, actionOptionIndexAdjusted) : removeMultiSelectIndex(state, indexLocation),
          multiSelectSelectedOptions: indexLocation === -1 ? addMultiSelectOption(state, actionOptionIndexAdjusted) : removeMultiSelectOption(state, indexLocation)
        });

        if (_nextState.multiSelectSelectedOptions.options.length === 0) {
          // Reset to noSelectionLabel if user has deselected all items and has set a `noSelectionLabel` prop
          if (state.noSelectionLabel) {
            _nextState = _extends({}, _nextState, {
              nextPotentialSelectionIndex: state.hasOptHeaders ? nextValidIndex(state, -1) : -1,
              multiSelectSelectedOptions: {
                options: getMultiSelectInitialSelectedOptions(state)
              }
            });
          } else if (!state.noSelectionLabel) {
            // Select first option if user has deselected all items
            _nextState = getInitialMultiSelectOption(state);
          }
        } // Set altered state


        return mergeIsAlteredState(_nextState);
      }

    default:
      return state;
  }
}

var MultiSelectOption = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(MultiSelectOption, _React$Component);

  function MultiSelectOption(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.optionRef = createRef();
    _this.scrollOffset = 0;
    return _this;
  }

  var _proto = MultiSelectOption.prototype;

  _proto.getScrollOffset = function getScrollOffset() {
    var el = document.querySelector('.rrs__option--header');
    return Math.ceil(el && el.getBoundingClientRect().height || 0);
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    var _this$props = this.props,
        index = _this$props.index,
        isOptionsPanelOpen = _this$props.isOptionsPanelOpen,
        nextPotentialSelectionIndex = _this$props.nextPotentialSelectionIndex,
        optionsContainerRef = _this$props.optionsContainerRef,
        optHeaderLabel = _this$props.optHeaderLabel;

    if (index === nextPotentialSelectionIndex && isOptionsPanelOpen) {
      if (this.optionRef.current && optionsContainerRef.current) {
        this.optionRef.current.focus();

        if (optHeaderLabel !== '') {
          var scrollDiff = Math.ceil(this.optionRef.current.getBoundingClientRect().top - optionsContainerRef.current.getBoundingClientRect().top);
          this.scrollOffset = this.scrollOffset || this.getScrollOffset();

          if (scrollDiff < this.scrollOffset) {
            optionsContainerRef.current.scroll(0, Math.floor(optionsContainerRef.current.scrollTop - this.scrollOffset));
          }
        }
      }
    }
  };

  _proto.isDisabled = function isDisabled(option) {
    return Boolean(option.disabled || option.optHeader);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        index = _this$props2.index,
        name = _this$props2.name,
        multiSelectSelectedIndexes = _this$props2.multiSelectSelectedIndexes,
        nextPotentialSelectionIndex = _this$props2.nextPotentialSelectionIndex,
        option = _this$props2.option,
        optHeaderLabel = _this$props2.optHeaderLabel;
    var isSelected = multiSelectSelectedIndexes.some(function (i) {
      return i === index;
    });
    return createElement("li", {
      role: "checkbox",
      "data-testid": "rrs-option_" + name + "_" + index,
      tabIndex: -1,
      "aria-checked": isSelected,
      "aria-label": "\n        " + (option.text || option.markup && option.markup.textContent) + " " + (optHeaderLabel !== '' ? " of " + optHeaderLabel : '') + "\n      ",
      "aria-live": "assertive",
      "aria-disabled": this.isDisabled(option) ? 'true' : 'false',
      "data-key": index,
      ref: this.optionRef,
      className: singleline("\n          rrs__option\n          " + (isSelected ? 'rrs__option--selected' : '') + "\n          " + (nextPotentialSelectionIndex === index ? 'rrs__option--next-selection' : '') + "\n          " + (option.disabled === true ? 'rrs__option--disabled' : '') + "\n          " + (option.optHeader === true ? 'rrs__option--header' : '') + "\n        ")
    }, option.markup || option.text);
  };

  return MultiSelectOption;
}(Component);

var MultiSelect = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(MultiSelect, _React$Component);

  function MultiSelect(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.optionsButton = createRef();
    _this.optionsContainer = createRef();
    return _this;
  }

  var _proto = MultiSelect.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    /*
      Focus selectBox button if options panel has just closed,
      there has been an interaction or the value has changed
    */
    var _this$props = this.props,
        isOptionsPanelOpen = _this$props.isOptionsPanelOpen,
        selectBoxRef = _this$props.selectBoxRef;
    var optionsPanelJustClosed = !isOptionsPanelOpen && prevProps.isOptionsPanelOpen;

    if (optionsPanelJustClosed && selectBoxRef && selectBoxRef.contains(document.activeElement)) {
      // tslint:disable-next-line
      this.optionsButton.current && this.optionsButton.current.focus();
    }
  };

  _proto.getAriaLabel = function getAriaLabel() {
    var _this$props2 = this.props,
        multiSelectSelectedOptions = _this$props2.multiSelectSelectedOptions,
        prefix = _this$props2.prefix;
    var selectedOptionsLength = multiSelectSelectedOptions.options.length;
    return singleline("\n      Checkbox group " + (prefix ? prefix + " " : '') + " has\n      " + selectedOptionsLength + " item" + (selectedOptionsLength === 1 ? '' : 's') + " selected.\n      Selected option" + (selectedOptionsLength === 1 ? '' : 's') + " " + (selectedOptionsLength === 1 ? 'is' : 'are') + "\n      " + multiSelectSelectedOptions.options.map(function (option) {
      return option.text || '';
    }).join(' and ') + "\n    ");
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props3 = this.props,
        caretIcon = _this$props3.caretIcon,
        customLabelText = _this$props3.customLabelText,
        disabled = _this$props3.disabled,
        isOptionsPanelOpen = _this$props3.isOptionsPanelOpen,
        multiSelectSelectedIndexes = _this$props3.multiSelectSelectedIndexes,
        multiSelectSelectedOptions = _this$props3.multiSelectSelectedOptions,
        name = _this$props3.name,
        options = _this$props3.options,
        nextPotentialSelectionIndex = _this$props3.nextPotentialSelectionIndex,
        prefix = _this$props3.prefix;
    var optHeaderLabel = '';
    return createElement("div", null, createElement("div", {
      role: "button",
      tabIndex: 0,
      "aria-disabled": disabled,
      "aria-haspopup": "true",
      "aria-expanded": isOptionsPanelOpen,
      "aria-controls": "rrs-" + name + "-menu",
      ref: this.optionsButton,
      className: singleline("\n            rrs__button\n            " + (disabled === true ? 'rrs__button--disabled' : '') + "\n          ")
    }, customLabelText && createElement("div", {
      className: "rrs__label"
    }, createElement("span", {
      "aria-label": this.getAriaLabel(),
      className: "rrs__label__text",
      id: "rrs-" + name + "-label",
      "data-testid": "rrs-label_" + name
    }, customLabelText), caretIcon && caretIcon), !customLabelText && createElement("div", {
      className: "rrs__label"
    }, createElement("span", {
      "aria-label": this.getAriaLabel(),
      className: "rrs__label__text",
      id: "rrs-" + name + "-label",
      "data-testid": "rrs-label_" + name
    }, createElement("span", {
      className: "rrs__multiselect-label"
    }, createElement("span", {
      className: "rrs__multiselect-label__text"
    }, (prefix ? prefix + " " : '') + "\n                  " + (multiSelectSelectedOptions.options.length > 0 ? multiSelectSelectedOptions.options[0].text : '')), multiSelectSelectedOptions.options.length > 1 && createElement("span", {
      className: "rrs__multiselect-label__badge"
    }, "+ " + (multiSelectSelectedOptions.options.length - 1)))), caretIcon && caretIcon), name && createElement("input", {
      type: "hidden",
      name: name,
      "data-testid": "rrs-input_" + name,
      value: [multiSelectSelectedOptions.options.map(function (v) {
        return v.value;
      })].join(',')
    })), createElement("ul", {
      id: "rrs-" + name + "-menu",
      "aria-labelledby": "rrs-" + name + "-label",
      role: "menu",
      className: "rrs__options",
      ref: this.optionsContainer
    }, options.length > 0 && options.map(function (option, index) {
      if (option.optHeader) {
        optHeaderLabel = option.text || option.markup && option.markup.textContent || '';
      }

      return createElement(MultiSelectOption, {
        key: index,
        name: name,
        optHeaderLabel: optHeaderLabel,
        optionsContainerRef: _this2.optionsContainer,
        index: index,
        option: option,
        isOptionsPanelOpen: isOptionsPanelOpen,
        multiSelectSelectedIndexes: multiSelectSelectedIndexes,
        nextPotentialSelectionIndex: nextPotentialSelectionIndex
      });
    })));
  };

  return MultiSelect;
}(Component);

var SingleSelectOption = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(SingleSelectOption, _React$Component);

  function SingleSelectOption(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.optionRef = createRef();
    _this.scrollOffset = 0;
    return _this;
  }

  var _proto = SingleSelectOption.prototype;

  _proto.getScrollOffset = function getScrollOffset() {
    var el = document.querySelector('.rrs__option--header');
    return Math.ceil(el && el.getBoundingClientRect().height || 0);
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    var _this$props = this.props,
        index = _this$props.index,
        isOptionsPanelOpen = _this$props.isOptionsPanelOpen,
        nextPotentialSelectionIndex = _this$props.nextPotentialSelectionIndex,
        optionsContainerRef = _this$props.optionsContainerRef,
        optHeaderLabel = _this$props.optHeaderLabel;

    if (index === nextPotentialSelectionIndex && isOptionsPanelOpen) {
      if (this.optionRef.current && optionsContainerRef.current) {
        this.optionRef.current.focus();

        if (optHeaderLabel !== '') {
          var scrollDiff = Math.ceil(this.optionRef.current.getBoundingClientRect().top - optionsContainerRef.current.getBoundingClientRect().top);
          this.scrollOffset = this.scrollOffset || this.getScrollOffset();

          if (scrollDiff < this.scrollOffset) {
            optionsContainerRef.current.scroll(0, Math.floor(optionsContainerRef.current.scrollTop - this.scrollOffset));
          }
        }
      }
    }
  };

  _proto.isDisabled = function isDisabled(option) {
    return Boolean(option.disabled || option.optHeader);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        index = _this$props2.index,
        name = _this$props2.name,
        nextPotentialSelectionIndex = _this$props2.nextPotentialSelectionIndex,
        option = _this$props2.option,
        singleSelectSelectedIndex = _this$props2.singleSelectSelectedIndex,
        optHeaderLabel = _this$props2.optHeaderLabel;
    return createElement("li", {
      role: "menuitem",
      "data-testid": "rrs-option_" + name + "_" + index,
      tabIndex: -1,
      "aria-disabled": this.isDisabled(option) ? 'true' : 'false',
      "aria-label": "\n          " + (option.text || option.markup && option.markup.textContent) + " " + (optHeaderLabel !== '' ? " of " + optHeaderLabel : '') + "\n        ",
      "data-key": index,
      ref: this.optionRef,
      className: singleline("\n          rrs__option\n          " + (singleSelectSelectedIndex === index ? 'rrs__option--selected' : '') + "\n          " + (nextPotentialSelectionIndex === index ? 'rrs__option--next-selection' : '') + "\n          " + (option.disabled === true ? 'rrs__option--disabled' : '') + "\n          " + (option.optHeader === true ? 'rrs__option--header' : '') + "\n        ")
    }, option.markup || option.text);
  };

  return SingleSelectOption;
}(Component);

var SingleSelect = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(SingleSelect, _React$Component);

  function SingleSelect(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.optionsButton = createRef();
    _this.optionsContainer = createRef();
    return _this;
  }

  var _proto = SingleSelect.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    /*
      Focus selectBox button if options panel has just closed,
      there has been an interaction,
      or isOptionsPanelOpen and nextPotentialSelectionIndex === -1
    */
    var _this$props = this.props,
        isOptionsPanelOpen = _this$props.isOptionsPanelOpen,
        nextPotentialSelectionIndex = _this$props.nextPotentialSelectionIndex,
        selectBoxRef = _this$props.selectBoxRef;
    var optionsPanelJustClosed = !isOptionsPanelOpen && prevProps.isOptionsPanelOpen;

    if (this.optionsButton.current) {
      if (optionsPanelJustClosed && selectBoxRef && selectBoxRef.contains(document.activeElement)) {
        this.optionsButton.current.focus();
      }

      if (isOptionsPanelOpen && nextPotentialSelectionIndex === -1) {
        this.optionsButton.current.focus();
      }
    }
  };

  _proto.getCustomLabel = function getCustomLabel() {
    var _this$props2 = this.props,
        prefix = _this$props2.prefix,
        name = _this$props2.name,
        singleSelectSelectedOption = _this$props2.singleSelectSelectedOption,
        caretIcon = _this$props2.caretIcon,
        customLabelText = _this$props2.customLabelText;
    return createElement("div", {
      className: "rrs__label"
    }, createElement("span", {
      "aria-label": "" + (prefix ? prefix + " " : '') + singleSelectSelectedOption.text + " selected",
      className: "rrs__label__text",
      id: "rrs-" + name + "-label",
      "data-testid": "rrs-label_" + name
    }, customLabelText), caretIcon && caretIcon);
  };

  _proto.getDefaultLabel = function getDefaultLabel() {
    var _this$props3 = this.props,
        prefix = _this$props3.prefix,
        singleSelectSelectedOption = _this$props3.singleSelectSelectedOption,
        name = _this$props3.name,
        caretIcon = _this$props3.caretIcon,
        singleSelectSelectedIndex = _this$props3.singleSelectSelectedIndex,
        noSelectionLabel = _this$props3.noSelectionLabel;

    if (singleSelectSelectedIndex === -1) {
      return createElement("div", {
        className: "rrs__label"
      }, createElement("span", {
        "aria-label": noSelectionLabel,
        className: "rrs__label__text",
        id: "rrs-" + name + "-label",
        "data-testid": "rrs-label_" + name
      }, prefix && createElement("span", null, prefix), noSelectionLabel), caretIcon && caretIcon);
    }

    return createElement("div", {
      className: "rrs__label"
    }, createElement("span", {
      "aria-label": "" + (prefix ? prefix + " " : '') + singleSelectSelectedOption.text + " selected",
      className: "rrs__label__text",
      id: "rrs-" + name + "-label",
      "data-testid": "rrs-label_" + name
    }, prefix && createElement("span", null, prefix), singleSelectSelectedOption.text ? singleSelectSelectedOption.text : createElement("span", null, "\xA0")), caretIcon && caretIcon);
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props4 = this.props,
        customLabelText = _this$props4.customLabelText,
        disabled = _this$props4.disabled,
        isOptionsPanelOpen = _this$props4.isOptionsPanelOpen,
        name = _this$props4.name,
        nextPotentialSelectionIndex = _this$props4.nextPotentialSelectionIndex,
        options = _this$props4.options,
        singleSelectSelectedIndex = _this$props4.singleSelectSelectedIndex,
        singleSelectSelectedOption = _this$props4.singleSelectSelectedOption;
    var optHeaderLabel = '';
    return createElement("div", null, createElement("div", {
      role: "button",
      tabIndex: 0,
      "aria-disabled": disabled,
      "aria-haspopup": "true",
      "aria-expanded": isOptionsPanelOpen,
      "aria-controls": "rrs-" + name + "-menu",
      ref: this.optionsButton,
      className: singleline("\n            rrs__button\n            " + (disabled === true ? 'rrs__button--disabled' : '') + "\n          ")
    }, customLabelText ? this.getCustomLabel() : this.getDefaultLabel(), name && createElement("input", {
      type: "hidden",
      name: name,
      "data-testid": "rrs-input_" + name,
      value: singleSelectSelectedOption.value
    })), createElement("ul", {
      id: "rrs-" + name + "-menu",
      "aria-labelledby": "rrs-" + name + "-label",
      role: "menu",
      className: "rrs__options",
      ref: this.optionsContainer
    }, options.length > 0 && options.map(function (option, index) {
      if (option.optHeader) {
        optHeaderLabel = option.text || option.markup && option.markup.textContent || '';
      }

      return createElement(SingleSelectOption, {
        key: index,
        name: name,
        optHeaderLabel: optHeaderLabel,
        optionsContainerRef: _this2.optionsContainer,
        index: index,
        isOptionsPanelOpen: isOptionsPanelOpen,
        option: option,
        singleSelectSelectedIndex: singleSelectSelectedIndex,
        nextPotentialSelectionIndex: nextPotentialSelectionIndex
      });
    })));
  };

  return SingleSelect;
}(Component);

/* tslint:disable:max-line-length*/

var CaretIcon = function CaretIcon(props) {
  return React__default.createElement("svg", Object.assign({
    className: "caret-icon",
    x: "0px",
    y: "0px",
    width: "11.848px",
    height: "6.338px",
    viewBox: "351.584 2118.292 11.848 6.338",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), React__default.createElement("g", null, React__default.createElement("path", {
    d: "M363.311,2118.414c-0.164-0.163-0.429-0.163-0.592,0l-5.205,5.216l-5.215-5.216c-0.163-0.163-0.429-0.163-0.592,0s-0.163,0.429,0,0.592l5.501,5.501c0.082,0.082,0.184,0.123,0.296,0.123c0.103,0,0.215-0.041,0.296-0.123l5.501-5.501C363.474,2118.843,363.474,2118.577,363.311,2118.414L363.311,2118.414z"
  })));
};
var ErrorIcon = function ErrorIcon(props) {
  return React__default.createElement("svg", Object.assign({
    x: "0px",
    y: "0px",
    width: "12px",
    height: "12px",
    viewBox: "0 0 1000 1000",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      fill: 'currentColor',
      marginRight: '4px'
    }
  }, props), React__default.createElement("g", null, React__default.createElement("path", {
    d: "M868,953.8H132.1c-49.3,0-89-19.3-108.8-53.1C3.5,867,5.9,822.9,29.9,779.8l371.3-665.4c24.2-43.4,60.1-68.2,98.6-68.2c38.5,0,74.4,24.8,98.6,68.2L970,779.9c24,43.1,26.5,87.1,6.7,120.8C956.9,934.5,917.3,953.8,868,953.8L868,953.8z M499.8,116.1c-12.2,0-26.2,12.1-37.6,32.4L90.9,813.9c-11.6,20.9-14.4,39.6-7.4,51.5c7,11.8,24.7,18.6,48.5,18.6H868c23.9,0,41.6-6.7,48.5-18.6c6.9-11.8,4.2-30.6-7.4-51.4L537.4,148.5C526.1,128.2,512,116.1,499.8,116.1L499.8,116.1z M500,638.7c-19.3,0-34.9-15.6-34.9-34.9V289.5c0-19.3,15.6-34.9,34.9-34.9c19.3,0,34.9,15.6,34.9,34.9v314.3C534.9,623.1,519.3,638.7,500,638.7z M447.6,761.1c0,28.9,23.5,52.4,52.4,52.4c28.9,0,52.4-23.5,52.4-52.4c0-28.9-23.5-52.4-52.4-52.4C471.1,708.7,447.6,732.2,447.6,761.1z"
  })));
};
var ModalCloseButton = function ModalCloseButton(props) {
  return React__default.createElement("div", null, React__default.createElement("svg", Object.assign({
    className: "mobile-close__icon",
    xmlns: "http://www.w3.org/2000/svg",
    width: "12px",
    height: "12px",
    viewBox: "0 0 2541 2541"
  }, props), React__default.createElement("path", {
    d: "M29 172c-39-39-39-103 0-142s103-39 142 0l1099 1099L2369 30c39-39 103-39 142 0s39 103 0 142L1412 1271l1099 1099c39 39 39 103 0 142s-103 39-142 0L1270 1413 171 2512c-39 39-103 39-142 0s-39-103 0-142l1099-1099L29 172z"
  })));
};
var CheckboxIcon = function CheckboxIcon(props) {
  return React__default.createElement("svg", Object.assign({
    className: "checkbox-icon",
    xmlns: "http://www.w3.org/2000/svg",
    x: "0px",
    y: "0px",
    width: "12px",
    height: "12px",
    viewBox: "0 0 488.878 488.878"
  }, props), React__default.createElement("g", null, React__default.createElement("polygon", {
    points: "143.294,340.058 50.837,247.602 0,298.439 122.009,420.447 122.149,420.306 144.423,442.58 488.878,98.123 437.055,46.298 "
  })));
};
var MultiSelectOptionMarkup = function MultiSelectOptionMarkup(_ref) {
  var text = _ref.text,
      props = _objectWithoutPropertiesLoose(_ref, ["text"]);

  return React__default.createElement("div", {
    className: "checkbox-container"
  }, React__default.createElement("span", {
    className: "checkbox"
  }, React__default.createElement(CheckboxIcon, Object.assign({}, props))), React__default.createElement("span", {
    className: "checkbox-text"
  }, " ", text));
};
/* tslint:enable:max-line-length */

var Select = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Select, _React$Component);

  function Select(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _this.onHandleKeyEvent = function (e) {
      handleKeyEvent({
        event: e,
        RRSClassRef: _assertThisInitialized(_this),
        state: _this.state,
        props: _this.props
      });
    };

    _this.onHandleTouchStart = function (_e) {
      handleTouchStart({
        RRSClassRef: _assertThisInitialized(_this),
        state: _this.state
      });
    };

    _this.onHandleTouchMove = function (_e) {
      handleTouchMove({
        RRSClassRef: _assertThisInitialized(_this),
        state: _this.state
      });
    };

    _this.onHandleClick = function (e) {
      handleClick({
        event: e,
        RRSClassRef: _assertThisInitialized(_this),
        state: _this.state,
        props: _this.props
      });
    };

    _this.onHandleBlur = function (_e) {
      handleBlur({
        RRSClassRef: _assertThisInitialized(_this),
        state: _this.state,
        props: _this.props
      });
    };

    _this.state = initialState;
    _this.reducer = reducer;
    _this.firstLoad = true;
    _this.selectBox = null;
    return _this;
  }

  var _proto = Select.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this$props = this.props,
        options = _this$props.options,
        noSelectionLabel = _this$props.noSelectionLabel,
        selectedValue = _this$props.selectedValue,
        selectedValues = _this$props.selectedValues,
        name = _this$props.name,
        multiselect = _this$props.multiselect,
        disabled = _this$props.disabled;
    this.updateState({
      type: INITIALISE,
      value: {
        options: options,
        noSelectionLabel: noSelectionLabel,
        selectedValue: selectedValue,
        selectedValues: selectedValues,
        name: name,
        multiselect: multiselect,
        disabled: disabled
      }
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {
    var _this$state = this.state,
        singleSelectSelectedOption = _this$state.singleSelectSelectedOption,
        multiSelectSelectedOptions = _this$state.multiSelectSelectedOptions,
        multiselect = _this$state.multiselect,
        altered = _this$state.altered;
    var onChange = this.props.onChange;

    if (this.firstLoad) {
      this.firstLoad = false;
      return false;
    }

    if (multiselect) {
      multiSelectBroadcastChange(multiSelectSelectedOptions.options, Boolean(altered), onChange, prevState.multiSelectSelectedOptions.options);
    } else {
      singleSelectBroadcastChange(singleSelectSelectedOption, Boolean(altered), onChange, prevState.singleSelectSelectedOption);
    }

    return true;
  };

  _proto.updateState = function updateState(action, callback) {
    var _this$props2 = this.props,
        onListen = _this$props2.onListen,
        name = _this$props2.name;
    var nextState = this.reducer(this.state, action);
    this.setState(nextState, function () {
      if (callback) {
        callback(nextState);
      }
    });
    /* Allow user to listen to actions being fired */

    if (onListen) {
      var isOpen = [SET_OPTIONS_PANEL_OPEN, SET_NEXT_SELECTED_INDEX, SET_NEXT_SELECTED_INDEX_ALPHA_NUMERIC, SET_IS_DRAGGING].some(function (actionType) {
        return action.type === actionType;
      });
      onListen(isOpen, name, action.type);
    }
  };

  _proto.focusButton = function focusButton() {
    var el = this.selectBox && this.selectBox.querySelector('.rrs__button'); // tslint:disable-next-line no-unused-expression

    el && el.focus();
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props3 = this.props,
        prefix = _this$props3.prefix,
        caretIcon = _this$props3.caretIcon,
        modalCloseButton = _this$props3.modalCloseButton;
    var _this$state2 = this.state,
        altered = _this$state2.altered,
        disabled = _this$state2.disabled,
        hasOptHeaders = _this$state2.hasOptHeaders,
        isOptionsPanelOpen = _this$state2.isOptionsPanelOpen,
        isDragging = _this$state2.isDragging,
        noSelectionLabel = _this$state2.noSelectionLabel,
        multiSelectSelectedIndexes = _this$state2.multiSelectSelectedIndexes,
        multiSelectSelectedOptions = _this$state2.multiSelectSelectedOptions,
        name = _this$state2.name,
        nextPotentialSelectionIndex = _this$state2.nextPotentialSelectionIndex,
        options = _this$state2.options,
        singleSelectSelectedIndex = _this$state2.singleSelectSelectedIndex,
        singleSelectSelectedOption = _this$state2.singleSelectSelectedOption,
        multiselect = _this$state2.multiselect;
    var customLabelText = getCustomLabelText({
      props: this.props,
      state: this.state
    });
    return createElement("div", {
      "data-testid": name,
      "data-name": name,
      className: singleline("\n          rrs\n          " + (isOptionsPanelOpen === true ? 'rrs--options-visible' : '') + "\n          " + (altered ? 'rrs--has-changed' : '') + "\n          " + (hasOptHeaders ? 'rrs--has-opt-headers' : '') + "\n        "),
      ref: function ref(r) {
        _this2.selectBox = r;
      },
      tabIndex: -1,
      onKeyDown: this.onHandleKeyEvent,
      onTouchStart: this.onHandleTouchStart,
      onTouchMove: this.onHandleTouchMove,
      onTouchEnd: this.onHandleClick,
      onMouseDown: this.onHandleClick,
      onBlur: this.onHandleBlur
    }, !!modalCloseButton && isOptionsPanelOpen === true && createElement("div", {
      "aria-hidden": "true",
      className: "mobile-close"
    }, modalCloseButton), multiselect ? createElement(MultiSelect, {
      disabled: Boolean(disabled),
      isDragging: isDragging,
      caretIcon: caretIcon,
      customLabelText: customLabelText,
      prefix: prefix || '',
      name: name,
      multiSelectSelectedOptions: multiSelectSelectedOptions,
      multiSelectSelectedIndexes: multiSelectSelectedIndexes,
      nextPotentialSelectionIndex: nextPotentialSelectionIndex,
      isOptionsPanelOpen: isOptionsPanelOpen,
      options: options,
      selectBoxRef: this.selectBox
    }) : createElement(SingleSelect, {
      noSelectionLabel: noSelectionLabel || '',
      disabled: Boolean(disabled),
      caretIcon: caretIcon,
      prefix: prefix || '',
      name: name,
      customLabelText: customLabelText,
      singleSelectSelectedOption: singleSelectSelectedOption,
      singleSelectSelectedIndex: singleSelectSelectedIndex,
      nextPotentialSelectionIndex: nextPotentialSelectionIndex,
      isOptionsPanelOpen: isOptionsPanelOpen,
      options: options,
      selectBoxRef: this.selectBox
    }));
  };

  return Select;
}(Component);

export { CaretIcon, CheckboxIcon, ErrorIcon, ModalCloseButton, MultiSelectOptionMarkup, Select };
//# sourceMappingURL=react-responsive-select.esm.js.map
